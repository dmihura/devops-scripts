#!/bin/bash

###################################
##           Fonctions           ##
###################################

# Fonction pour initialiser le fichier .env s'il n'existe pas
check_env_file() {
  if [ ! -f .env ]; then
    echo "Le fichier .env n'existe pas. Un fichier par défaut vient d'être généré. Merci de le remplir avec vos identifiants."
    echo '#  URL du gitlab
GITLAB_URL="https://mongitlab.com/gitlab/api/v4"

#  répertoire où cloner les repositories (chemin en linux style)
OUTPUT_DIRECTORY="."

# Créer un token avec le scope "api" au minimum (c.f. : https://docs.gitlab.com/user/profile/personal_access_tokens/#create-a-personal-access-token)
PRIVATE_TOKEN="<token>"

# Credentials sous la forme username:password. Indispensable dans le cas gitlab production line.
CREDENTIALS="username:password"' >.env
    exit 1
  fi
}

# Fonction pour récupérer tous les projects
get_projects() {
  curl -s --header "PRIVATE-TOKEN: $PRIVATE_TOKEN" -u "${CREDENTIALS}" "$GITLAB_URL/projects"
}

# Fonction pour cloner un projet
clone_project() {
  local project_url=$1
  local directory=$2

  full_path="${directory}/$(basename "$project_url" .git)"
  echo -n "Clonage du repo ${project_url} ..."
  if [ ! -d "${full_path}" ]; then
    echo "" # nouvelle ligne
    git clone "$project_url" "${full_path}"
  else
    echo " déjà cloné."
  fi
}

##############################
##           Main           ##
##############################
main() {
  # Chargement des properties
  check_env_file && source ".env"

  echo "Récupération de tous les gits du projet."

  # Certains repository on des noms très longs.
  # Ce contournement est utilisé plutôt que de renommer les noms de fichiers.
  git config --global core.longpaths true

  # récupération des projets (urls et arborescence) associés au group id.
  echo -n "Identification de tous les projects du gitlab ..."
  projects=$(get_projects)
  project_urls=($(echo "${projects}" | jq -r '.[].http_url_to_repo' | xargs ))
  full_paths=($(echo "${projects}" | jq -r '.[].namespace.full_path' | xargs))

  nb_projects=${#project_urls[@]}
  echo "OK."

  # si il n'y a d'url de projet, c'est qu'on n'a rien à récupérer => next
  if [ "${nb_projects}" -eq 0 ] ; then
    echo "Vous n'avez accès à aucun repository."
    exit 1
  fi

  # Sinon, on récupère l'arborescence du projet dans le répo, on reconstruit l'arborescence et on le git clone dedans
  for j in $(seq 0 $((nb_projects-1))); do
   project_url=$(echo "${project_urls[$j]}" | xargs)
   full_path="${OUTPUT_DIRECTORY}/$(echo "${full_paths[$j]}" | xargs)"
   mkdir -p "${full_path}"
   clone_project "${project_url}" "${full_path}"
  done
}

main